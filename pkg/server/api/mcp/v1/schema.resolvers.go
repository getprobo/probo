package mcp_v1

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by mcpgen. DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"go.probo.inc/probo/pkg/authz"
	"go.probo.inc/probo/pkg/coredata"
	"go.probo.inc/probo/pkg/page"
	"go.probo.inc/probo/pkg/probo"
	"go.probo.inc/probo/pkg/server/api/mcp/v1/types"
	serverauth "go.probo.inc/probo/pkg/server/auth"
)

// ListOrganizationsTool handles the listOrganizations tool
// List all organizations the user has access to
func (r *Resolver) ListOrganizationsTool(ctx context.Context, req *mcp.CallToolRequest, input *types.ListOrganizationsInput) (*mcp.CallToolResult, types.ListOrganizationsOutput, error) {
	user := serverauth.UserFromContext(ctx)
	if user == nil {
		return nil, types.ListOrganizationsOutput{}, fmt.Errorf("authentication required")
	}

	organizations, err := r.authzSvc.GetAllUserOrganizations(ctx, user.ID)
	if err != nil {
		return nil, types.ListOrganizationsOutput{}, fmt.Errorf("failed to list organizations: %w", err)
	}

	result := types.ListOrganizationsOutput{
		Organizations: make([]*types.Organization, 0, len(organizations)),
	}

	for _, org := range organizations {
		result.Organizations = append(result.Organizations, types.NewOrganization(org))
	}

	return nil, result, nil
}

// ListVendorsTool handles the listVendors tool
// List all vendors for the organization
func (r *Resolver) ListVendorsTool(ctx context.Context, req *mcp.CallToolRequest, input *types.ListVendorsInput) (*mcp.CallToolResult, types.ListVendorsOutput, error) {
	r.MustBeAuthorized(ctx, input.OrganizationID, authz.ActionListVendors)

	prb := r.ProboService(ctx, input.OrganizationID)

	pageOrderBy := page.OrderBy[coredata.VendorOrderField]{
		Field:     coredata.VendorOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}
	if input.OrderBy != nil {
		pageOrderBy = page.OrderBy[coredata.VendorOrderField]{
			Field:     input.OrderBy.Field,
			Direction: input.OrderBy.Direction,
		}
	}

	cursor := types.NewCursor(input.Size, input.Cursor, pageOrderBy)

	var vendorFilter = coredata.NewVendorFilter(nil, nil)
	if input.Filter != nil {
		vendorFilter = coredata.NewVendorFilter(&input.Filter.SnapshotID, nil)
	}

	page, err := prb.Vendors.ListForOrganizationID(ctx, input.OrganizationID, cursor, vendorFilter)
	if err != nil {
		panic(fmt.Errorf("cannot list organization vendors: %w", err))
	}

	return nil, types.NewListVendorsOutput(page), nil
}

// AddVendorTool handles the addVendor tool
// Add a new vendor to the organization
func (r *Resolver) AddVendorTool(ctx context.Context, req *mcp.CallToolRequest, input *types.AddVendorInput) (*mcp.CallToolResult, types.AddVendorOutput, error) {
	r.MustBeAuthorized(ctx, input.OrganizationID, authz.ActionCreateAsset)

	svc := r.ProboService(ctx, input.OrganizationID)

	vendor, err := svc.Vendors.Create(
		ctx,
		probo.CreateVendorRequest{
			OrganizationID: input.OrganizationID,
			Name:           input.Name,
			Description:    input.Description,
			// HeadquarterAddress:            input.HeadquarterAddress,
			// LegalName:                     input.LegalName,
			// WebsiteURL:                    input.WebsiteURL,
			// Category:                      input.Category,
			// PrivacyPolicyURL:              input.PrivacyPolicyURL,
			// ServiceLevelAgreementURL:      input.ServiceLevelAgreementURL,
			// DataProcessingAgreementURL:    input.DataProcessingAgreementURL,
			// BusinessAssociateAgreementURL: input.BusinessAssociateAgreementURL,
			// SubprocessorsListURL:          input.SubprocessorsListURL,
			// Certifications:                input.Certifications,
			// Countries:                     input.Countries,
			// SecurityPageURL:               input.SecurityPageURL,
			// TrustPageURL:                  input.TrustPageURL,
			// TermsOfServiceURL:             input.TermsOfServiceURL,
			// StatusPageURL:                 input.StatusPageURL,
			// BusinessOwnerID:               input.BusinessOwnerID,
			// SecurityOwnerID:               input.SecurityOwnerID,
		},
	)
	if err != nil {
		return nil, types.AddVendorOutput{}, fmt.Errorf("failed to create vendor: %w", err)
	}

	return nil, types.NewAddVendorOutput(vendor), nil
}

// UpdateVendorTool handles the updateVendor tool
// Update an existing vendor
func (r *Resolver) UpdateVendorTool(ctx context.Context, req *mcp.CallToolRequest, input *types.UpdateVendorInput) (*mcp.CallToolResult, types.UpdateVendorOutput, error) {

	return nil, types.UpdateVendorOutput{}, fmt.Errorf("updateVendor not implemented")
}

func (r *Resolver) ListPeopleTool(ctx context.Context, req *mcp.CallToolRequest, input *types.ListPeopleInput) (*mcp.CallToolResult, types.ListPeopleOutput, error) {
	r.MustBeAuthorized(ctx, input.OrganizationID, authz.ActionListPeople)

	prb := r.ProboService(ctx, input.OrganizationID)

	pageOrderBy := page.OrderBy[coredata.PeopleOrderField]{
		Field:     coredata.PeopleOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}
	if input.OrderBy != nil {
		pageOrderBy = page.OrderBy[coredata.PeopleOrderField]{
			Field:     input.OrderBy.Field,
			Direction: input.OrderBy.Direction,
		}
	}

	cursor := types.NewCursor(input.Size, input.Cursor, pageOrderBy)

	var peopleFilter = coredata.NewPeopleFilter(nil)
	if input.Filter != nil {
		peopleFilter = coredata.NewPeopleFilter(input.Filter.ExcludeContractEnded)
	}

	page, err := prb.Peoples.ListForOrganizationID(ctx, input.OrganizationID, cursor, peopleFilter)
	if err != nil {
		panic(fmt.Errorf("cannot list organization people: %w", err))
	}

	return nil, types.NewListPeopleOutput(page), nil
}

func (r *Resolver) GetPeopleTool(ctx context.Context, req *mcp.CallToolRequest, input *types.GetPeopleInput) (*mcp.CallToolResult, types.GetPeopleOutput, error) {
	r.MustBeAuthorized(ctx, input.ID, authz.ActionGet)

	prb := r.ProboService(ctx, input.ID)

	people, err := prb.Peoples.Get(ctx, input.ID)
	if err != nil {
		return nil, types.GetPeopleOutput{}, fmt.Errorf("failed to get people: %w", err)
	}

	return nil, types.GetPeopleOutput{
		People: types.NewPeople(people),
	}, nil
}

func (r *Resolver) AddPeopleTool(ctx context.Context, req *mcp.CallToolRequest, input *types.AddPeopleInput) (*mcp.CallToolResult, types.AddPeopleOutput, error) {
	r.MustBeAuthorized(ctx, input.OrganizationID, authz.ActionCreatePeople)

	svc := r.ProboService(ctx, input.OrganizationID)

	people, err := svc.Peoples.Create(
		ctx,
		probo.CreatePeopleRequest{
			OrganizationID:           input.OrganizationID,
			FullName:                 input.FullName,
			PrimaryEmailAddress:      input.PrimaryEmailAddress,
			AdditionalEmailAddresses: input.AdditionalEmailAddresses,
			Kind:                     input.Kind,
			Position:                 input.Position,
			ContractStartDate:        input.ContractStartDate,
			ContractEndDate:          input.ContractEndDate,
		},
	)
	if err != nil {
		return nil, types.AddPeopleOutput{}, fmt.Errorf("failed to create people: %w", err)
	}

	return nil, types.AddPeopleOutput{
		People: types.NewPeople(people),
	}, nil
}
