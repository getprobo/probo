package connect_v1

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.probo.inc/probo/pkg/coredata"
	"go.probo.inc/probo/pkg/gid"
	"go.probo.inc/probo/pkg/iam"
	"go.probo.inc/probo/pkg/page"
	"go.probo.inc/probo/pkg/securecookie"
	"go.probo.inc/probo/pkg/server/api/connect/v1/schema"
	"go.probo.inc/probo/pkg/server/api/connect/v1/types"
	"go.probo.inc/probo/pkg/server/gqlutils"
	"go.probo.inc/probo/pkg/server/gqlutils/types/cursor"
)

// Memberships is the resolver for the memberships field.
func (r *identityResolver) Memberships(ctx context.Context, obj *types.Identity, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.MembershipConnection, error) {
	pageOrderBy := page.OrderBy[coredata.MembershipOrderField]{
		Field:     coredata.MembershipOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.AccountService.ListMemberships(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list memberships: %w", err))
	}

	return types.NewMembershipConnection(page, r, obj.ID), nil
}

// PendingInvitations is the resolver for the pendingInvitations field.
func (r *identityResolver) PendingInvitations(ctx context.Context, obj *types.Identity, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.InvitationConnection, error) {
	pageOrderBy := page.OrderBy[coredata.InvitationOrderField]{
		Field:     coredata.InvitationOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.AccountService.ListPendingInvitations(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list pending invitations: %w", err))
	}

	return types.NewInvitationConnection(page, r, obj.ID, nil), nil
}

// Sessions is the resolver for the sessions field.
func (r *identityResolver) Sessions(ctx context.Context, obj *types.Identity, first *int, after *page.CursorKey, last *int, before *page.CursorKey, orderBy *types.SessionOrder) (*types.SessionConnection, error) {
	pageOrderBy := page.OrderBy[coredata.SessionOrderField]{
		Field:     coredata.SessionOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}
	if orderBy != nil {
		pageOrderBy = page.OrderBy[coredata.SessionOrderField]{
			Field:     orderBy.Field,
			Direction: orderBy.Direction,
		}
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.AccountService.ListSessions(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list sessions: %w", err))
	}

	return types.NewSessionConnection(page, r, obj.ID), nil
}

// PersonalAPIKeys is the resolver for the personalAPIKeys field.
func (r *identityResolver) PersonalAPIKeys(ctx context.Context, obj *types.Identity, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.PersonalAPIKeyConnection, error) {
	pageOrderBy := page.OrderBy[coredata.UserAPIKeyOrderField]{
		Field:     coredata.UserAPIKeyOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.AccountService.ListPersonalAPIKeys(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list personal api keys: %w", err))
	}

	return types.NewPersonalAPIKeyConnection(page, r, obj.ID), nil
}

// TotalCount is the resolver for the totalCount field.
func (r *invitationConnectionResolver) TotalCount(ctx context.Context, obj *types.InvitationConnection) (int, error) {
	switch obj.Resolver.(type) {
	case *organizationResolver:
		count, err := r.iam.OrganizationService.CountInvitations(ctx, obj.ParentID, obj.Filters)
		if err != nil {
			panic(fmt.Errorf("cannot count invitations: %w", err))
		}
		return count, nil
	case *identityResolver:
		count, err := r.iam.AccountService.CountPendingInvitations(ctx, obj.ParentID)
		if err != nil {
			panic(fmt.Errorf("cannot count invitations: %w", err))
		}

		return count, nil
	}

	panic(fmt.Errorf("unsupported resolver: %T", obj.Resolver))
}

// Identity is the resolver for the identity field.
func (r *membershipResolver) Identity(ctx context.Context, obj *types.Membership) (*types.Identity, error) {
	identity, err := r.iam.AccountService.GetIdentityForMembership(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot get identity: %w", err))
	}

	return types.NewIdentity(identity), nil
}

// Organization is the resolver for the organization field.
func (r *membershipResolver) Organization(ctx context.Context, obj *types.Membership) (*types.Organization, error) {
	organization, err := r.iam.OrganizationService.GetOrganizationForMembership(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot get organization for membership: %w", err))
	}

	return types.NewOrganization(organization), nil
}

// TotalCount is the resolver for the totalCount field.
func (r *membershipConnectionResolver) TotalCount(ctx context.Context, obj *types.MembershipConnection) (int, error) {
	switch obj.Resolver.(type) {
	case *identityResolver:
		count, err := r.iam.AccountService.CountMemberships(ctx, obj.ParentID)
		if err != nil {
			panic(fmt.Errorf("cannot count memberships: %w", err))
		}

		return count, nil
	}

	panic(fmt.Errorf("unsupported resolver: %T", obj.Resolver))
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input types.SignInInput) (*types.SignInPayload, error) {
	user, session, err := r.iam.AuthService.OpenSessionWithPassword(ctx, input.Email, input.Password)
	if err != nil {
		var ErrInvalidCredentials *iam.ErrInvalidCredentials
		if errors.As(err, &ErrInvalidCredentials) {
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "INVALID_CREDENTIALS",
				},
			}
		}

		// TODO handle error properly here
		panic(fmt.Errorf("cannot sign in: %w", err))
	}

	w := HTTPResponseWriterFromContext(ctx)
	securecookie.Set(
		w,
		r.sessionCookieConfig(time.Until(session.ExpiredAt)),
		session.ID.String(),
	)

	return &types.SignInPayload{
		Identity: &types.Identity{
			ID:            user.ID,
			Email:         user.EmailAddress,
			EmailVerified: user.EmailAddressVerified,
			CreatedAt:     user.CreatedAt,
			UpdatedAt:     user.UpdatedAt,
		},
	}, nil
}

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input types.SignUpInput) (*types.SignUpPayload, error) {
	identity, session, err := r.iam.AuthService.CreateIdentityWithPassword(
		ctx,
		&iam.CreateIdentityWithPasswordRequest{
			Email:    input.Email,
			Password: input.Password,
			FullName: input.FullName,
		},
	)
	if err != nil {
		// TODO handle error properly here
		panic(fmt.Errorf("cannot create identity with password: %w", err))
	}

	w := HTTPResponseWriterFromContext(ctx)
	securecookie.Set(
		w,
		r.sessionCookieConfig(time.Until(session.ExpiredAt)),
		session.ID.String(),
	)

	return &types.SignUpPayload{
		Identity: types.NewIdentity(identity),
	}, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (*types.SignOutPayload, error) {
	session := SessionFromContext(ctx)

	err := r.iam.SessionService.CloseSession(ctx, session.ID)
	if err != nil {
		var ErrSessionNotFound *iam.ErrSessionNotFound
		if errors.As(err, &ErrSessionNotFound) {
			return &types.SignOutPayload{}, nil
		}

		panic(fmt.Errorf("cannot close session: %w", err))
	}

	return &types.SignOutPayload{Success: true}, nil
}

// SignUpFromInvitation is the resolver for the signUpFromInvitation field.
func (r *mutationResolver) SignUpFromInvitation(ctx context.Context, input types.SignUpFromInvitationInput) (*types.SignUpFromInvitationPayload, error) {
	identity, session, err := r.iam.AuthService.CreateIdentityFromInvitation(
		ctx,
		&iam.CreateIdentityFromInvitationRequest{
			InvitationToken: input.Token,
			Password:        input.Password,
		},
	)
	if err != nil {
		// TODO handle error properly here
		panic(fmt.Errorf("cannot create identity from invitation: %w", err))
	}

	w := HTTPResponseWriterFromContext(ctx)
	securecookie.Set(
		w,
		r.sessionCookieConfig(time.Until(session.ExpiredAt)),
		session.ID.String(),
	)

	return &types.SignUpFromInvitationPayload{
		Identity: &types.Identity{
			ID:            identity.ID,
			Email:         identity.EmailAddress,
			EmailVerified: identity.EmailAddressVerified,
			CreatedAt:     identity.CreatedAt,
			UpdatedAt:     identity.UpdatedAt,
		},
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input types.ForgotPasswordInput) (*types.ForgotPasswordPayload, error) {
	err := r.iam.AuthService.SendPasswordResetInstructionByEmail(
		ctx,
		input.Email,
	)
	if err != nil {
		// TODO handle error properly here
		panic(fmt.Errorf("cannot send password reset instruction by email: %w", err))
	}

	return &types.ForgotPasswordPayload{
		Success: true,
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input types.ResetPasswordInput) (*types.ResetPasswordPayload, error) {
	err := r.iam.AuthService.ResetPassword(
		ctx,
		&iam.ResetPasswordRequest{
			Token:    input.Token,
			Password: input.Password,
		},
	)
	if err != nil {
		var errInvalidToken *iam.ErrInvalidToken
		if errors.As(err, &errInvalidToken) {
			return nil, gqlutils.Invalid(err, nil)
		}

		panic(fmt.Errorf("cannot reset password: %w", err))
	}

	return &types.ResetPasswordPayload{
		Success: true,
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, input types.VerifyEmailInput) (*types.VerifyEmailPayload, error) {
	err := r.iam.AccountService.VerifyEmail(ctx, input.Token)
	if err != nil {
		// TODO handle error properly here
		panic(fmt.Errorf("cannot verify email: %w", err))
	}

	return &types.VerifyEmailPayload{
		Success: true,
	}, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input types.ChangePasswordInput) (*types.ChangePasswordPayload, error) {
	identity := UserFromContext(ctx)

	err := r.iam.AccountService.ChangePassword(
		ctx,
		identity.ID,
		&iam.ChangePasswordRequest{
			CurrentPassword: input.CurrentPassword,
			NewPassword:     input.NewPassword,
		},
	)
	if err != nil {
		// TODO handle error properly here
		panic(fmt.Errorf("cannot change password: %w", err))
	}

	return &types.ChangePasswordPayload{
		Success: true,
	}, nil
}

// ChangeEmail is the resolver for the changeEmail field.
func (r *mutationResolver) ChangeEmail(ctx context.Context, input types.ChangeEmailInput) (*types.ChangeEmailPayload, error) {
	identity := UserFromContext(ctx)

	err := r.iam.AccountService.ChangeEmail(
		ctx,
		identity.ID,
		&iam.ChangeEmailRequest{
			NewEmail: input.NewEmail,
			Password: input.Password,
		},
	)
	if err != nil {
		// TODO handle error properly here
		panic(fmt.Errorf("cannot change email: %w", err))
	}

	return &types.ChangeEmailPayload{
		Success: true,
	}, nil
}

// UpdateIdentityProfile is the resolver for the updateIdentityProfile field.
func (r *mutationResolver) UpdateIdentityProfile(ctx context.Context, input types.UpdateIdentityProfileInput) (*types.UpdateIdentityProfilePayload, error) {
	panic(fmt.Errorf("not implemented: UpdateIdentityProfile - updateIdentityProfile"))
}

// RevokeSession is the resolver for the revokeSession field.
func (r *mutationResolver) RevokeSession(ctx context.Context, input types.RevokeSessionInput) (*types.RevokeSessionPayload, error) {
	identity := UserFromContext(ctx)

	err := r.iam.SessionService.RevokeSession(ctx, identity.ID, input.SessionID)
	if err != nil {
		var ErrSessionExpired *iam.ErrSessionExpired
		if errors.As(err, &ErrSessionExpired) {
			return &types.RevokeSessionPayload{Success: true}, nil
		}

		panic(fmt.Errorf("cannot revoke session: %w", err))
	}

	return &types.RevokeSessionPayload{Success: true}, nil
}

// RevokeAllSessions is the resolver for the revokeAllSessions field.
func (r *mutationResolver) RevokeAllSessions(ctx context.Context) (*types.RevokeAllSessionsPayload, error) {
	session := SessionFromContext(ctx)

	revokedCount, err := r.iam.SessionService.RevokeAllSessions(ctx, session.ID)
	if err != nil {
		panic(fmt.Errorf("cannot revoke all sessions: %w", err))
	}

	return &types.RevokeAllSessionsPayload{RevokedCount: int(revokedCount)}, nil
}

// CreatePersonalAPIKey is the resolver for the createPersonalAPIKey field.
func (r *mutationResolver) CreatePersonalAPIKey(ctx context.Context, input types.CreatePersonalAPIKeyInput) (*types.CreatePersonalAPIKeyPayload, error) {
	identity := UserFromContext(ctx)

	userAPIKey, token, err := r.iam.AccountService.CreatePersonalAPIKey(
		ctx,
		identity.ID,
		input.Name,
		input.ExpiresAt,
	)
	if err != nil {
		panic(fmt.Errorf("cannot create personal api key: %w", err))
	}

	return &types.CreatePersonalAPIKeyPayload{
		PersonalAPIKeyEdge: types.NewPersonalAPIKeyEdge(userAPIKey, coredata.UserAPIKeyOrderFieldCreatedAt),
		Token:              token,
	}, nil
}

// UpdatePersonalAPIKey is the resolver for the updatePersonalAPIKey field.
func (r *mutationResolver) UpdatePersonalAPIKey(ctx context.Context, input types.UpdatePersonalAPIKeyInput) (*types.UpdatePersonalAPIKeyPayload, error) {
	panic(fmt.Errorf("not implemented: UpdatePersonalAPIKey - updatePersonalAPIKey"))
}

// RevokePersonalAPIKey is the resolver for the revokePersonalAPIKey field.
func (r *mutationResolver) RevokePersonalAPIKey(ctx context.Context, input types.RevokePersonalAPIKeyInput) (*types.RevokePersonalAPIKeyPayload, error) {
	identity := UserFromContext(ctx)

	err := r.iam.AccountService.DeletePersonalAPIKey(ctx, identity.ID, input.TokenID)
	if err != nil {
		panic(fmt.Errorf("cannot delete personal api key: %w", err))
	}

	return &types.RevokePersonalAPIKeyPayload{Success: true}, nil
}

// CreateOrganization is the resolver for the createOrganization field.
func (r *mutationResolver) CreateOrganization(ctx context.Context, input types.CreateOrganizationInput) (*types.CreateOrganizationPayload, error) {
	identity := UserFromContext(ctx)

	var (
		logoFile           *iam.UploadedFile
		horizontalLogoFile *iam.UploadedFile
	)

	if input.LogoFile != nil {
		logoFile = &iam.UploadedFile{
			Content:     input.LogoFile.File,
			Filename:    input.LogoFile.Filename,
			ContentType: input.LogoFile.ContentType,
			Size:        input.LogoFile.Size,
		}
	}

	if input.HorizontalLogoFile != nil {
		horizontalLogoFile = &iam.UploadedFile{
			Content:     input.HorizontalLogoFile.File,
			Filename:    input.HorizontalLogoFile.Filename,
			ContentType: input.HorizontalLogoFile.ContentType,
			Size:        input.HorizontalLogoFile.Size,
		}
	}
	organization, err := r.iam.OrganizationService.CreateOrganization(
		ctx,
		identity.ID,
		&iam.CreateOrganizationRequest{
			Name:               input.Name,
			LogoFile:           logoFile,
			HorizontalLogoFile: horizontalLogoFile,
		},
	)
	if err != nil {
		panic(fmt.Errorf("cannot create organization: %w", err))
	}

	return &types.CreateOrganizationPayload{
		Organization: types.NewOrganization(organization),
	}, nil
}

// UpdateOrganization is the resolver for the updateOrganization field.
func (r *mutationResolver) UpdateOrganization(ctx context.Context, input types.UpdateOrganizationInput) (*types.UpdateOrganizationPayload, error) {
	organization, err := r.iam.OrganizationService.UpdateOrganization(
		ctx,
		input.OrganizationID,
		&iam.UpdateOrganizationRequest{
			Name: input.Name,
		},
	)
	if err != nil {
		panic(fmt.Errorf("cannot update organization: %w", err))
	}

	return &types.UpdateOrganizationPayload{
		Organization: &types.Organization{
			ID:        organization.ID,
			Name:      organization.Name,
			CreatedAt: organization.CreatedAt,
			UpdatedAt: organization.UpdatedAt,
		},
	}, nil
}

// DeleteOrganization is the resolver for the deleteOrganization field.
func (r *mutationResolver) DeleteOrganization(ctx context.Context, input types.DeleteOrganizationInput) (*types.DeleteOrganizationPayload, error) {
	err := r.iam.OrganizationService.DeleteOrganization(ctx, input.OrganizationID)
	if err != nil {
		panic(fmt.Errorf("cannot delete organization: %w", err))
	}

	return &types.DeleteOrganizationPayload{DeletedOrganizationID: input.OrganizationID}, nil
}

// InviteMember is the resolver for the inviteMember field.
func (r *mutationResolver) InviteMember(ctx context.Context, input types.InviteMemberInput) (*types.InviteMemberPayload, error) {
	invitation, err := r.iam.OrganizationService.InviteMember(
		ctx,
		input.OrganizationID,
		input.Email,
		input.FullName,
		coredata.MembershipRoleViewer,
	)
	if err != nil {
		var errOrganizationNotFound *iam.ErrOrganizationNotFound
		var errMembershipAlreadyExists *iam.ErrMembershipAlreadyExists

		if errors.As(err, &errOrganizationNotFound) {
			return nil, gqlutils.NotFound(err)
		}

		if errors.As(err, &errMembershipAlreadyExists) {
			return nil, gqlutils.Conflict(err)
		}

		panic(fmt.Errorf("cannot add member to organization: %w", err))
	}

	return &types.InviteMemberPayload{
		InvitationEdge: types.NewInvitationEdge(invitation, coredata.InvitationOrderFieldCreatedAt),
	}, nil
}

// DeleteInvitation is the resolver for the deleteInvitation field.
func (r *mutationResolver) DeleteInvitation(ctx context.Context, input types.DeleteInvitationInput) (*types.DeleteInvitationPayload, error) {
	err := r.iam.OrganizationService.DeleteInvitation(ctx, input.OrganizationID, input.InvitationID)
	if err != nil {
		var errInvitationNotFound *iam.ErrInvitationNotFound
		var errInvitationNotPending *iam.ErrInvitationNotPending

		if errors.As(err, &errInvitationNotFound) {
			return nil, gqlutils.NotFound(err)
		}

		if errors.As(err, &errInvitationNotPending) {
			return nil, gqlutils.Invalid(err, nil)
		}

		panic(fmt.Errorf("cannot delete invitation: %w", err))
	}

	return &types.DeleteInvitationPayload{DeletedInvitationID: input.InvitationID}, nil
}

// RemoveMember is the resolver for the removeMember field.
func (r *mutationResolver) RemoveMember(ctx context.Context, input types.RemoveMemberInput) (*types.RemoveMemberPayload, error) {
	err := r.iam.OrganizationService.RemoveMember(ctx, input.OrganizationID, input.MembershipID)
	if err != nil {
		panic(fmt.Errorf("cannot remove member from organization: %w", err))
	}

	return &types.RemoveMemberPayload{DeletedMembershipID: input.MembershipID}, nil
}

// AcceptInvitation is the resolver for the acceptInvitation field.
func (r *mutationResolver) AcceptInvitation(ctx context.Context, input types.AcceptInvitationInput) (*types.AcceptInvitationPayload, error) {
	identity := UserFromContext(ctx)

	membership, err := r.iam.AccountService.AcceptInvitation(ctx, identity.ID, input.InvitationID)
	if err != nil {
		panic(fmt.Errorf("cannot accept invitation: %w", err))
	}

	return &types.AcceptInvitationPayload{
		MembershipEdge: types.NewMembershipEdge(membership, coredata.MembershipOrderFieldCreatedAt),
	}, nil
}

// CreateSAMLConfiguration is the resolver for the createSAMLConfiguration field.
func (r *mutationResolver) CreateSAMLConfiguration(ctx context.Context, input types.CreateSAMLConfigurationInput) (*types.CreateSAMLConfigurationPayload, error) {
	req := &iam.CreateSAMLConfigurationRequest{
		EmailDomain:       input.EmailDomain,
		IdPEntityID:       input.IdpEntityID,
		IdPSsoURL:         input.IdpSsoURL,
		IdPCertificate:    input.IdpCertificate,
		AutoSignupEnabled: input.AutoSignupEnabled,
	}

	if input.AttributeMappings != nil {
		req.AttributeEmail = input.AttributeMappings.Email
		req.AttributeFirstname = input.AttributeMappings.FirstName
		req.AttributeLastname = input.AttributeMappings.LastName
		req.AttributeRole = input.AttributeMappings.Role
	}

	samlConfiguration, err := r.iam.OrganizationService.CreateSAMLConfiguration(
		ctx,
		input.OrganizationID,
		req,
	)

	if err != nil {
		panic(fmt.Errorf("cannot create saml configuration: %w", err))
	}

	return &types.CreateSAMLConfigurationPayload{
		SamlConfigurationEdge: types.NewSAMLConfigurationEdge(
			samlConfiguration,
			coredata.SAMLConfigurationOrderFieldCreatedAt,
		),
	}, nil
}

// UpdateSAMLConfiguration is the resolver for the updateSAMLConfiguration field.
func (r *mutationResolver) UpdateSAMLConfiguration(ctx context.Context, input types.UpdateSAMLConfigurationInput) (*types.UpdateSAMLConfigurationPayload, error) {
	req := &iam.UpdateSAMLConfigurationRequest{
		IdPEntityID:       input.IdpEntityID,
		IdPSsoURL:         input.IdpSsoURL,
		IdPCertificate:    input.IdpCertificate,
		AutoSignupEnabled: input.AutoSignupEnabled,
	}

	if input.AttributeMappings != nil {
		req.AttributeEmail = input.AttributeMappings.Email
		req.AttributeFirstname = input.AttributeMappings.FirstName
		req.AttributeLastname = input.AttributeMappings.LastName
		req.AttributeRole = input.AttributeMappings.Role
	}

	samlConfiguration, err := r.iam.OrganizationService.UpdateSAMLConfiguration(
		ctx,
		input.OrganizationID,
		input.SamlConfigurationID,
		req,
	)
	if err != nil {
		panic(fmt.Errorf("cannot update saml configuration: %w", err))
	}

	return &types.UpdateSAMLConfigurationPayload{
		SamlConfiguration: types.NewSAMLConfiguration(samlConfiguration),
	}, nil
}

// DeleteSAMLConfiguration is the resolver for the deleteSAMLConfiguration field.
func (r *mutationResolver) DeleteSAMLConfiguration(ctx context.Context, input types.DeleteSAMLConfigurationInput) (*types.DeleteSAMLConfigurationPayload, error) {
	err := r.iam.OrganizationService.DeleteSAMLConfiguration(ctx, input.OrganizationID, input.SamlConfigurationID)
	if err != nil {
		panic(fmt.Errorf("cannot delete saml configuration: %w", err))
	}

	return &types.DeleteSAMLConfigurationPayload{DeletedSamlConfigurationID: input.SamlConfigurationID}, nil
}

// LogoURL is the resolver for the logoUrl field.
func (r *organizationResolver) LogoURL(ctx context.Context, obj *types.Organization) (*string, error) {
	presignedURL, err := r.iam.OrganizationService.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
	if err != nil {
		panic(fmt.Errorf("cannot generate logo URL: %w", err))
	}

	return presignedURL, nil
}

// HorizontalLogoURL is the resolver for the horizontalLogoUrl field.
func (r *organizationResolver) HorizontalLogoURL(ctx context.Context, obj *types.Organization) (*string, error) {
	presignedURL, err := r.iam.OrganizationService.GenerateHorizontalLogoURL(ctx, obj.ID, 1*time.Hour)
	if err != nil {
		panic(fmt.Errorf("cannot generate horizontal logo URL: %w", err))
	}

	return presignedURL, nil
}

// Members is the resolver for the members field.
func (r *organizationResolver) Members(ctx context.Context, obj *types.Organization, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.MembershipConnection, error) {
	pageOrderBy := page.OrderBy[coredata.MembershipOrderField]{
		Field:     coredata.MembershipOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.OrganizationService.ListMembers(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list memberships: %w", err))
	}

	return types.NewMembershipConnection(page, r, obj.ID), nil
}

// Invitations is the resolver for the invitations field.
func (r *organizationResolver) Invitations(ctx context.Context, obj *types.Organization, first *int, after *page.CursorKey, last *int, before *page.CursorKey, status *coredata.InvitationStatus) (*types.InvitationConnection, error) {
	pageOrderBy := page.OrderBy[coredata.InvitationOrderField]{
		Field:     coredata.InvitationOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}

	filters := coredata.NewInvitationFilter(nil)
	if status != nil {
		filters = coredata.NewInvitationFilter([]coredata.InvitationStatus{*status})
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.OrganizationService.ListInvitations(ctx, obj.ID, cursor, filters)
	if err != nil {
		panic(fmt.Errorf("cannot list invitations: %w", err))
	}

	return types.NewInvitationConnection(page, r, obj.ID, filters), nil
}

// SamlConfigurations is the resolver for the samlConfigurations field.
func (r *organizationResolver) SamlConfigurations(ctx context.Context, obj *types.Organization, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.SAMLConfigurationConnection, error) {
	pageOrderBy := page.OrderBy[coredata.SAMLConfigurationOrderField]{
		Field:     coredata.SAMLConfigurationOrderFieldCreatedAt,
		Direction: page.OrderDirectionDesc,
	}

	cursor := cursor.NewCursor(first, after, last, before, pageOrderBy)

	page, err := r.iam.OrganizationService.ListSAMLConfigurations(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list saml configurations: %w", err))
	}

	return types.NewSAMLConfigurationConnection(page, r, obj.ID), nil
}

// TotalCount is the resolver for the totalCount field.
func (r *personalAPIKeyConnectionResolver) TotalCount(ctx context.Context, obj *types.PersonalAPIKeyConnection) (int, error) {
	switch obj.Resolver.(type) {
	case *identityResolver:
		count, err := r.iam.AccountService.CountPersonalAPIKeys(ctx, obj.ParentID)
		if err != nil {
			panic(fmt.Errorf("cannot count personal api keys: %w", err))
		}

		return count, nil
	}

	panic(fmt.Errorf("unsupported resolver: %T", obj.Resolver))
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id gid.GID) (types.Node, error) {
	var loadNode func(ctx context.Context, id gid.GID) (types.Node, error)

	user := UserFromContext(ctx)

	r.iam.AccessManagementService.Authorize(ctx, user.ID, nil, id, iam.ActionGet)

	switch id.EntityType() {
	case coredata.OrganizationEntityType:
		loadNode = func(ctx context.Context, id gid.GID) (types.Node, error) {
			organization, err := r.iam.OrganizationService.GetOrganization(ctx, id)
			if err != nil {
				return nil, err
			}
			return types.NewOrganization(organization), nil
		}
	case coredata.UserEntityType:
		loadNode = func(ctx context.Context, id gid.GID) (types.Node, error) {
			identity, err := r.iam.AccountService.GetIdentity(ctx, id)
			if err != nil {
				return nil, err
			}

			return types.NewIdentity(identity), nil
		}
	case coredata.SessionEntityType:
		loadNode = func(ctx context.Context, id gid.GID) (types.Node, error) {
			session, err := r.iam.GetSession(ctx, id)
			if err != nil {
				return nil, err
			}

			return types.NewSession(session), nil
		}
	case coredata.MembershipEntityType:
		loadNode = func(ctx context.Context, id gid.GID) (types.Node, error) {
			membership, err := r.iam.GetMembership(ctx, id)
			if err != nil {
				return nil, err
			}

			return types.NewMembership(membership), nil
		}
	case coredata.InvitationEntityType:
		loadNode = func(ctx context.Context, id gid.GID) (types.Node, error) {
			invitation, err := r.iam.GetInvitation(ctx, id)
			if err != nil {
				return nil, err
			}

			return types.NewInvitation(invitation), nil
		}
	default:
		return nil, fmt.Errorf("unsupported entity type: %d", id.EntityType())
	}

	node, err := loadNode(ctx, id)
	if err != nil {
		var (
			errOrganizationNotFound *iam.ErrOrganizationNotFound
			errIdentityNotFound     *iam.ErrUserNotFound
			errSessionNotFound      *iam.ErrSessionNotFound
			errMembershipNotFound   *iam.ErrMembershipNotFound
			errInvitationNotFound   *iam.ErrInvitationNotFound
		)

		if errors.As(err, &errOrganizationNotFound) ||
			errors.As(err, &errIdentityNotFound) ||
			errors.As(err, &errSessionNotFound) ||
			errors.As(err, &errMembershipNotFound) ||
			errors.As(err, &errInvitationNotFound) {
			return nil, gqlutils.NotFound(err)
		}

		return nil, err
	}

	return node, nil
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (*types.Identity, error) {
	user := UserFromContext(ctx)

	return &types.Identity{
		ID:            user.ID,
		Email:         user.EmailAddress,
		EmailVerified: user.EmailAddressVerified,
		CreatedAt:     user.CreatedAt,
		UpdatedAt:     user.UpdatedAt,
	}, nil
}

// CheckSSOAvailability is the resolver for the checkSSOAvailability field.
func (r *queryResolver) CheckSSOAvailability(ctx context.Context, email string) (*types.SSOAvailability, error) {
	panic(fmt.Errorf("not implemented: CheckSSOAvailability - checkSSOAvailability"))
}

// TotalCount is the resolver for the totalCount field.
func (r *sAMLConfigurationConnectionResolver) TotalCount(ctx context.Context, obj *types.SAMLConfigurationConnection) (int, error) {
	switch obj.Resolver.(type) {
	case *organizationResolver:
		count, err := r.iam.OrganizationService.CountSAMLConfigurations(ctx, obj.ParentID)
		if err != nil {
			panic(fmt.Errorf("cannot count saml configurations: %w", err))
		}
		return count, nil
	}

	panic(fmt.Errorf("unsupported resolver: %T", obj.Resolver))
}

// TotalCount is the resolver for the totalCount field.
func (r *sessionConnectionResolver) TotalCount(ctx context.Context, obj *types.SessionConnection) (int, error) {
	switch obj.Resolver.(type) {
	case *identityResolver:
		count, err := r.iam.AccountService.CountSessions(ctx, obj.ParentID)
		if err != nil {
			panic(fmt.Errorf("cannot count sessions: %w", err))
		}

		return count, nil
	}

	panic(fmt.Errorf("unsupported resolver: %T", obj.Resolver))
}

// Identity returns schema.IdentityResolver implementation.
func (r *Resolver) Identity() schema.IdentityResolver { return &identityResolver{r} }

// InvitationConnection returns schema.InvitationConnectionResolver implementation.
func (r *Resolver) InvitationConnection() schema.InvitationConnectionResolver {
	return &invitationConnectionResolver{r}
}

// Membership returns schema.MembershipResolver implementation.
func (r *Resolver) Membership() schema.MembershipResolver { return &membershipResolver{r} }

// MembershipConnection returns schema.MembershipConnectionResolver implementation.
func (r *Resolver) MembershipConnection() schema.MembershipConnectionResolver {
	return &membershipConnectionResolver{r}
}

// Mutation returns schema.MutationResolver implementation.
func (r *Resolver) Mutation() schema.MutationResolver { return &mutationResolver{r} }

// Organization returns schema.OrganizationResolver implementation.
func (r *Resolver) Organization() schema.OrganizationResolver { return &organizationResolver{r} }

// PersonalAPIKeyConnection returns schema.PersonalAPIKeyConnectionResolver implementation.
func (r *Resolver) PersonalAPIKeyConnection() schema.PersonalAPIKeyConnectionResolver {
	return &personalAPIKeyConnectionResolver{r}
}

// Query returns schema.QueryResolver implementation.
func (r *Resolver) Query() schema.QueryResolver { return &queryResolver{r} }

// SAMLConfigurationConnection returns schema.SAMLConfigurationConnectionResolver implementation.
func (r *Resolver) SAMLConfigurationConnection() schema.SAMLConfigurationConnectionResolver {
	return &sAMLConfigurationConnectionResolver{r}
}

// SessionConnection returns schema.SessionConnectionResolver implementation.
func (r *Resolver) SessionConnection() schema.SessionConnectionResolver {
	return &sessionConnectionResolver{r}
}

type identityResolver struct{ *Resolver }
type invitationConnectionResolver struct{ *Resolver }
type membershipResolver struct{ *Resolver }
type membershipConnectionResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type organizationResolver struct{ *Resolver }
type personalAPIKeyConnectionResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sAMLConfigurationConnectionResolver struct{ *Resolver }
type sessionConnectionResolver struct{ *Resolver }
