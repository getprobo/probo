package trust_v1

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/base64"
	"fmt"
	"time"

	"github.com/getprobo/probo/pkg/coredata"
	"github.com/getprobo/probo/pkg/page"
	"github.com/getprobo/probo/pkg/server/api/trust/v1/schema"
	"github.com/getprobo/probo/pkg/server/api/trust/v1/types"
	"github.com/getprobo/probo/pkg/trust"
)

// Framework is the resolver for the framework field.
func (r *auditResolver) Framework(ctx context.Context, obj *types.Audit) (*types.Framework, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	audit, err := publicTrustService.Audits.Get(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load audit: %w", err))
	}

	framework, err := publicTrustService.Frameworks.Get(ctx, audit.FrameworkID)
	if err != nil {
		panic(fmt.Errorf("cannot load framework: %w", err))
	}

	return types.NewFramework(framework), nil
}

// Report is the resolver for the report field.
func (r *auditResolver) Report(ctx context.Context, obj *types.Audit) (*types.Report, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	audit, err := publicTrustService.Audits.Get(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load audit: %w", err))
	}

	if audit.ReportID == nil {
		return nil, nil
	}

	report, err := publicTrustService.Reports.Get(ctx, *audit.ReportID)
	if err != nil {
		panic(fmt.Errorf("cannot load report: %w", err))
	}

	return types.NewReport(report), nil
}

// CreateTrustCenterAccess is the resolver for the createTrustCenterAccess field.
func (r *mutationResolver) CreateTrustCenterAccess(ctx context.Context, input types.CreateTrustCenterAccessInput) (*types.CreateTrustCenterAccessPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.TrustCenterID.TenantID())

	access, err := publicTrustService.TrustCenterAccesses.Create(ctx, &trust.CreateTrustCenterAccessRequest{
		TrustCenterID: input.TrustCenterID,
		Email:         input.Email,
		Name:          input.Name,
	})
	if err != nil {
		panic(fmt.Errorf("cannot create trust center access: %w", err))
	}

	return &types.CreateTrustCenterAccessPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// ExportDocumentPDF is the resolver for the exportDocumentPDF field.
func (r *mutationResolver) ExportDocumentPDF(ctx context.Context, input types.ExportDocumentPDFInput) (*types.ExportDocumentPDFPayload, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, input.DocumentID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("cannot export document PDF: %w", err)
	}

	hasAcceptedNDA := false
	userData := UserFromContext(ctx)
	if userData != nil {
		hasAcceptedNDA = true
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		tokenData := TokenAccessFromContext(ctx)
		hasAcceptedNDA, err = privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, tokenData.TrustCenterID, tokenData.GetEmail())
		if err != nil {
			panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
		}
	}

	if !hasAcceptedNDA {
		return nil, fmt.Errorf("user has not accepted NDA")
	}

	pdf, err := privateTrustService.Documents.ExportPDF(ctx, input.DocumentID)
	if err != nil {
		panic(fmt.Errorf("cannot export document PDF: %w", err))
	}

	return &types.ExportDocumentPDFPayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
	}, nil
}

// AcceptNonDisclosureAgreement is the resolver for the acceptNonDisclosureAgreement field.
func (r *mutationResolver) AcceptNonDisclosureAgreement(ctx context.Context, input types.AcceptNonDisclosureAgreementInput) (*types.AcceptNonDisclosureAgreementPayload, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, input.TrustCenterID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("cannot accept NDA: %w", err)
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData == nil {
		return nil, fmt.Errorf("token not found")
	}

	err = privateTrustService.TrustCenterAccesses.AcceptNonDisclosureAgreement(ctx, input.TrustCenterID, tokenData.GetEmail())
	if err != nil {
		return nil, fmt.Errorf("cannot accept NDA: %w", err)
	}

	return &types.AcceptNonDisclosureAgreementPayload{Success: true}, nil
}

// LogoURL is the resolver for the logoUrl field.
func (r *organizationResolver) LogoURL(ctx context.Context, obj *types.Organization) (*string, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	return publicTrustService.Organizations.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
}

// TrustCenterBySlug is the resolver for the trustCenterBySlug field.
func (r *queryResolver) TrustCenterBySlug(ctx context.Context, slug string) (*types.TrustCenter, error) {
	rootTrustService := r.RootTrustService(ctx)

	trustCenter, err := rootTrustService.TrustCenters.GetBySlug(ctx, slug)
	if err != nil {
		return nil, nil
	}

	if !trustCenter.Active {
		return nil, nil
	}

	publicTrustService := r.PublicTrustService(ctx, trustCenter.TenantID)
	trustCenter, file, err := publicTrustService.TrustCenters.Get(ctx, trustCenter.ID)
	if err != nil {
		panic(fmt.Errorf("cannot get trust center: %w", err))
	}

	org, err := publicTrustService.Organizations.Get(ctx, trustCenter.OrganizationID)
	if err != nil {
		panic(fmt.Errorf("cannot get organization: %w", err))
	}
	response := types.NewTrustCenter(trustCenter, file)
	response.Organization = types.NewOrganization(org)

	return response, nil
}

// DownloadURL is the resolver for the downloadUrl field.
func (r *reportResolver) DownloadURL(ctx context.Context, obj *types.Report) (*string, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("cannot generate download URL: %w", err)
	}

	hasAcceptedNDA := false
	userData := UserFromContext(ctx)
	if userData != nil {
		hasAcceptedNDA = true
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		hasAcceptedNDA, err = privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, tokenData.TrustCenterID, tokenData.GetEmail())
		if err != nil {
			panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
		}
	}

	if !hasAcceptedNDA {
		return nil, fmt.Errorf("user has not accepted NDA")
	}

	url, err := privateTrustService.Reports.GenerateDownloadURL(ctx, obj.ID, r.trustAuthCfg.ReportURLDuration)
	if err != nil {
		panic(fmt.Errorf("cannot generate download URL: %w", err))
	}

	return url, nil
}

// NdaFileURL is the resolver for the ndaFileUrl field.
func (r *trustCenterResolver) NdaFileURL(ctx context.Context, obj *types.TrustCenter) (*string, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("failed to get private trust service: %w", err)
	}

	fileURL, err := privateTrustService.TrustCenters.GenerateNDAFileURL(ctx, obj.ID, 15*time.Minute)
	if err != nil {
		return nil, fmt.Errorf("failed to generate NDA file URL: %w", err)
	}

	return &fileURL, nil
}

// Organization is the resolver for the organization field.
func (r *trustCenterResolver) Organization(ctx context.Context, obj *types.TrustCenter) (*types.Organization, error) {
	return obj.Organization, nil
}

// IsUserAuthenticated is the resolver for the isUserAuthenticated field.
func (r *trustCenterResolver) IsUserAuthenticated(ctx context.Context, obj *types.TrustCenter) (bool, error) {
	_, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	return true, nil
}

// HasAcceptedNonDisclosureAgreement is the resolver for the hasAcceptedNonDisclosureAgreement field.
func (r *trustCenterResolver) HasAcceptedNonDisclosureAgreement(ctx context.Context, obj *types.TrustCenter) (bool, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := UserFromContext(ctx)
	if userData != nil {
		return true, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		hasAcceptedNDA, err := privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, obj.ID, tokenData.GetEmail())
		if err != nil {
			panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
		}
		return hasAcceptedNDA, nil
	}

	panic(fmt.Errorf("no user or token data found"))
}

// Documents is the resolver for the documents field.
func (r *trustCenterResolver) Documents(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.DocumentConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.DocumentOrderField]{
		Field:     coredata.DocumentOrderFieldTitle,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	documentPage, err := publicTrustService.Documents.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public documents: %w", err))
	}

	return types.NewDocumentConnection(documentPage), nil
}

// Audits is the resolver for the audits field.
func (r *trustCenterResolver) Audits(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.AuditConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.AuditOrderField]{
		Field:     coredata.AuditOrderFieldValidFrom,
		Direction: page.OrderDirectionDesc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	auditPage, err := publicTrustService.Audits.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public audits: %w", err))
	}

	return types.NewAuditConnection(auditPage), nil
}

// Vendors is the resolver for the vendors field.
func (r *trustCenterResolver) Vendors(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.VendorConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.VendorOrderField]{
		Field:     coredata.VendorOrderFieldName,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	vendorPage, err := publicTrustService.Vendors.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public vendors: %w", err))
	}

	return types.NewVendorConnection(vendorPage), nil
}

// Audit returns schema.AuditResolver implementation.
func (r *Resolver) Audit() schema.AuditResolver { return &auditResolver{r} }

// Mutation returns schema.MutationResolver implementation.
func (r *Resolver) Mutation() schema.MutationResolver { return &mutationResolver{r} }

// Organization returns schema.OrganizationResolver implementation.
func (r *Resolver) Organization() schema.OrganizationResolver { return &organizationResolver{r} }

// Query returns schema.QueryResolver implementation.
func (r *Resolver) Query() schema.QueryResolver { return &queryResolver{r} }

// Report returns schema.ReportResolver implementation.
func (r *Resolver) Report() schema.ReportResolver { return &reportResolver{r} }

// TrustCenter returns schema.TrustCenterResolver implementation.
func (r *Resolver) TrustCenter() schema.TrustCenterResolver { return &trustCenterResolver{r} }

type auditResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type organizationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reportResolver struct{ *Resolver }
type trustCenterResolver struct{ *Resolver }
