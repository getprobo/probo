package trust_v1

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/base64"
	"fmt"
	"time"

	"github.com/getprobo/probo/pkg/coredata"
	"github.com/getprobo/probo/pkg/gid"
	"github.com/getprobo/probo/pkg/page"
	"github.com/getprobo/probo/pkg/server/api/trust/v1/schema"
	"github.com/getprobo/probo/pkg/server/api/trust/v1/types"
	"github.com/getprobo/probo/pkg/trust"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Framework is the resolver for the framework field.
func (r *auditResolver) Framework(ctx context.Context, obj *types.Audit) (*types.Framework, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	audit, err := publicTrustService.Audits.Get(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load audit: %w", err))
	}

	framework, err := publicTrustService.Frameworks.Get(ctx, audit.FrameworkID)
	if err != nil {
		panic(fmt.Errorf("cannot load framework: %w", err))
	}

	return types.NewFramework(framework), nil
}

// Report is the resolver for the report field.
func (r *auditResolver) Report(ctx context.Context, obj *types.Audit) (*types.Report, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	audit, err := publicTrustService.Audits.Get(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load audit: %w", err))
	}

	if audit.ReportID == nil {
		return nil, nil
	}

	report, err := publicTrustService.Reports.Get(ctx, *audit.ReportID)
	if err != nil {
		panic(fmt.Errorf("cannot load report: %w", err))
	}

	return types.NewReport(report), nil
}

// IsUserAuthorized is the resolver for the isUserAuthorized field.
func (r *documentResolver) IsUserAuthorized(ctx context.Context, obj *types.Document) (bool, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	document, err := publicTrustService.Documents.Get(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load document: %w", err))
	}

	if document.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return true, nil
	}

	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return true, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		documentAccess, err := privateTrustService.TrustCenterAccesses.LoadDocumentAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), obj.ID)
		if err != nil {
			return false, nil
		}

		return documentAccess.Active, nil
	}

	panic(fmt.Errorf("no user or token data found"))
}

// HasUserRequestedAccess is the resolver for the hasUserRequestedAccess field.
func (r *documentResolver) HasUserRequestedAccess(ctx context.Context, obj *types.Document) (bool, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return false, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		// Try to load document access - if it exists (regardless of active status), user has requested it
		_, err := privateTrustService.TrustCenterAccesses.LoadDocumentAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), obj.ID)
		if err != nil {
			return false, nil // No access requested or error
		}
		return true, nil // Access exists (requested)
	}

	return false, nil
}

// RequestAllAccesses is the resolver for the requestAllAccesses field.
func (r *mutationResolver) RequestAllAccesses(ctx context.Context, input types.RequestAllAccessesInput) (*types.RequestAccessesPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.TrustCenterID.TenantID())

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return nil, fmt.Errorf("session users cannot request trust center access")
	}

	email := input.Email
	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		if email != nil || input.Name != nil {
			return nil, fmt.Errorf("email and name are not allowed for authenticated users")
		}
		emailValue := tokenData.GetEmail()
		email = &emailValue
	}
	if email == nil {
		return nil, fmt.Errorf("email is required for unauthenticated users")
	}

	access, err := publicTrustService.TrustCenterAccesses.Request(ctx, &trust.TrustCenterAccessRequest{
		TrustCenterID: input.TrustCenterID,
		Email:         *email,
		Name:          input.Name,
		DocumentIDs:   nil,
		ReportIDs:     nil,
	})
	if err != nil {
		panic(fmt.Errorf("cannot create trust center access: %w", err))
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// ExportDocumentPDF is the resolver for the exportDocumentPDF field.
func (r *mutationResolver) ExportDocumentPDF(ctx context.Context, input types.ExportDocumentPDFInput) (*types.ExportDocumentPDFPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.DocumentID.TenantID())

	document, err := publicTrustService.Documents.Get(ctx, input.DocumentID)
	if err != nil {
		panic(fmt.Errorf("cannot load document: %w", err))
	}

	if document.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		pdf, err := publicTrustService.Documents.ExportPDFWithoutWatermark(ctx, input.DocumentID)
		if err != nil {
			panic(fmt.Errorf("cannot export document PDF: %w", err))
		}

		return &types.ExportDocumentPDFPayload{
			Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
		}, nil
	}

	privateTrustService, err := r.PrivateTrustService(ctx, input.DocumentID.TenantID())
	if err != nil {
		panic(fmt.Errorf("cannot export document PDF: %w", err))
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		ndaExists := true
		hasAcceptedNDA := false

		trustCenter, _, err := privateTrustService.TrustCenters.Get(ctx, tokenData.TrustCenterID)
		if err != nil {
			panic(fmt.Errorf("cannot get trust center: %w", err))
		}
		if trustCenter.NonDisclosureAgreementFileID == nil {
			ndaExists = false
		}

		if ndaExists {
			tokenData := TokenAccessFromContext(ctx)
			hasAcceptedNDA, err = privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, tokenData.TrustCenterID, tokenData.GetEmail())
			if err != nil {
				panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
			}
		}

		documentAccess, err := privateTrustService.TrustCenterAccesses.LoadDocumentAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), input.DocumentID)
		if err != nil {
			panic(fmt.Errorf("cannot check document access: %w", err))
		}

		if !documentAccess.Active {
			return nil, fmt.Errorf("access denied: no permission to access this document")
		}

		if ndaExists && !hasAcceptedNDA {
			return nil, fmt.Errorf("user has not accepted NDA")
		}
	}

	userData := UserFromContext(ctx)
	userEmail := ""
	if userData != nil {
		userEmail = userData.EmailAddress
	}
	if tokenData != nil {
		userEmail = tokenData.GetEmail()
	}

	pdf, err := privateTrustService.Documents.ExportPDF(ctx, input.DocumentID, userEmail)
	if err != nil {
		panic(fmt.Errorf("cannot export document PDF: %w", err))
	}

	return &types.ExportDocumentPDFPayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
	}, nil
}

// ExportReportPDF is the resolver for the exportReportPDF field.
func (r *mutationResolver) ExportReportPDF(ctx context.Context, input types.ExportReportPDFInput) (*types.ExportReportPDFPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.ReportID.TenantID())

	audit, err := publicTrustService.Audits.GetByReportID(ctx, input.ReportID)
	if err != nil {
		panic(fmt.Errorf("cannot load audit: %w", err))
	}

	if audit.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		pdf, err := publicTrustService.Reports.ExportPDFWithoutWatermark(ctx, input.ReportID)
		if err != nil {
			panic(fmt.Errorf("cannot export report PDF: %w", err))
		}

		return &types.ExportReportPDFPayload{
			Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
		}, nil
	}

	privateTrustService, err := r.PrivateTrustService(ctx, input.ReportID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("cannot export report PDF: %w", err)
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		ndaExists := true
		hasAcceptedNDA := false

		trustCenter, _, err := privateTrustService.TrustCenters.Get(ctx, tokenData.TrustCenterID)
		if err != nil {
			panic(fmt.Errorf("cannot get trust center: %w", err))
		}
		if trustCenter.NonDisclosureAgreementFileID == nil {
			ndaExists = false
		}

		if ndaExists {
			hasAcceptedNDA, err = privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, tokenData.TrustCenterID, tokenData.GetEmail())
			if err != nil {
				panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
			}
		}

		reportAccess, err := privateTrustService.TrustCenterAccesses.LoadReportAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), input.ReportID)
		if err != nil {
			panic(fmt.Errorf("cannot check report access: %w", err))
		}

		if !reportAccess.Active {
			return nil, fmt.Errorf("access denied: no permission to access this report")
		}

		if ndaExists && !hasAcceptedNDA {
			return nil, fmt.Errorf("user has not accepted NDA")
		}
	}

	userData := UserFromContext(ctx)
	userEmail := ""
	if userData != nil {
		userEmail = userData.EmailAddress
	}
	if tokenData != nil {
		userEmail = tokenData.GetEmail()
	}

	pdf, err := privateTrustService.Reports.ExportPDF(ctx, input.ReportID, userEmail)
	if err != nil {
		panic(fmt.Errorf("cannot export report PDF: %w", err))
	}

	return &types.ExportReportPDFPayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
	}, nil
}

// AcceptNonDisclosureAgreement is the resolver for the acceptNonDisclosureAgreement field.
func (r *mutationResolver) AcceptNonDisclosureAgreement(ctx context.Context, input types.AcceptNonDisclosureAgreementInput) (*types.AcceptNonDisclosureAgreementPayload, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, input.TrustCenterID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("cannot accept NDA: %w", err)
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData == nil {
		return nil, fmt.Errorf("token not found")
	}

	err = privateTrustService.TrustCenterAccesses.AcceptNonDisclosureAgreement(ctx, input.TrustCenterID, tokenData.GetEmail())
	if err != nil {
		return nil, fmt.Errorf("cannot accept NDA: %w", err)
	}

	return &types.AcceptNonDisclosureAgreementPayload{Success: true}, nil
}

// RequestDocumentAccess is the resolver for the requestDocumentAccess field.
func (r *mutationResolver) RequestDocumentAccess(ctx context.Context, input types.RequestDocumentAccessInput) (*types.RequestAccessesPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.TrustCenterID.TenantID())

	document, err := publicTrustService.Documents.Get(ctx, input.DocumentID)
	if err != nil {
		panic(fmt.Errorf("cannot load document: %w", err))
	}

	if document.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return nil, fmt.Errorf("document is publicly available and does not require access request")
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return nil, fmt.Errorf("sessions users cannot request trust center access")
	}

	email := input.Email
	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		if email != nil || input.Name != nil {
			return nil, fmt.Errorf("email and name are not allowed for authenticated users")
		}
		emailValue := tokenData.GetEmail()
		email = &emailValue
	}
	if email == nil {
		return nil, fmt.Errorf("email is required for unauthenticated users")
	}

	access, err := publicTrustService.TrustCenterAccesses.Request(ctx, &trust.TrustCenterAccessRequest{
		TrustCenterID: input.TrustCenterID,
		Email:         *email,
		Name:          input.Name,
		DocumentIDs:   []gid.GID{input.DocumentID},
		ReportIDs:     []gid.GID{},
	})
	if err != nil {
		panic(fmt.Errorf("cannot request document access: %w", err))
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// RequestReportAccess is the resolver for the requestReportAccess field.
func (r *mutationResolver) RequestReportAccess(ctx context.Context, input types.RequestReportAccessInput) (*types.RequestAccessesPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.TrustCenterID.TenantID())

	audit, err := publicTrustService.Audits.GetByReportID(ctx, input.ReportID)
	if err != nil {
		panic(fmt.Errorf("cannot load audit: %w", err))
	}

	if audit.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return nil, fmt.Errorf("report is publicly available and does not require access request")
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return nil, fmt.Errorf("session users cannot request trust center access")
	}

	email := input.Email
	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		if email != nil || input.Name != nil {
			return nil, fmt.Errorf("email and name are not allowed for authenticated users")
		}
		emailValue := tokenData.GetEmail()
		email = &emailValue
	}
	if email == nil {
		return nil, fmt.Errorf("email is required for unauthenticated users")
	}

	access, err := publicTrustService.TrustCenterAccesses.Request(ctx, &trust.TrustCenterAccessRequest{
		TrustCenterID: input.TrustCenterID,
		Email:         *email,
		Name:          input.Name,
		DocumentIDs:   []gid.GID{},
		ReportIDs:     []gid.GID{input.ReportID},
	})
	if err != nil {
		panic(fmt.Errorf("cannot request report access: %w", err))
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// RequestTrustCenterFileAccess is the resolver for the requestTrustCenterFileAccess field.
func (r *mutationResolver) RequestTrustCenterFileAccess(ctx context.Context, input types.RequestTrustCenterFileAccessInput) (*types.RequestAccessesPayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.TrustCenterID.TenantID())

	trustCenterFile, err := publicTrustService.TrustCenterFiles.Get(ctx, input.TrustCenterFileID)
	if err != nil {
		panic(fmt.Errorf("cannot load trust center file: %w", err))
	}

	if trustCenterFile.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return nil, fmt.Errorf("trust center file is publicly available and does not require access request")
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return nil, fmt.Errorf("session users cannot request trust center access")
	}

	email := input.Email
	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		if email != nil || input.Name != nil {
			return nil, fmt.Errorf("email and name are not allowed for authenticated users")
		}
		emailValue := tokenData.GetEmail()
		email = &emailValue
	}
	if email == nil {
		return nil, fmt.Errorf("email is required for unauthenticated users")
	}

	access, err := publicTrustService.TrustCenterAccesses.Request(ctx, &trust.TrustCenterAccessRequest{
		TrustCenterID:      input.TrustCenterID,
		Email:              *email,
		Name:               input.Name,
		DocumentIDs:        []gid.GID{},
		ReportIDs:          []gid.GID{},
		TrustCenterFileIDs: []gid.GID{input.TrustCenterFileID},
	})
	if err != nil {
		panic(fmt.Errorf("cannot request trust center file access: %w", err))
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// ExportTrustCenterFile is the resolver for the exportTrustCenterFile field.
func (r *mutationResolver) ExportTrustCenterFile(ctx context.Context, input types.ExportTrustCenterFileInput) (*types.ExportTrustCenterFilePayload, error) {
	publicTrustService := r.PublicTrustService(ctx, input.TrustCenterFileID.TenantID())

	trustCenterFile, err := publicTrustService.TrustCenterFiles.Get(ctx, input.TrustCenterFileID)
	if err != nil {
		panic(fmt.Errorf("cannot load trust center file: %w", err))
	}

	if trustCenterFile.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		fileData, err := publicTrustService.TrustCenterFiles.ExportFileWithoutWatermark(ctx, input.TrustCenterFileID)
		if err != nil {
			panic(fmt.Errorf("cannot export trust center file: %w", err))
		}

		return &types.ExportTrustCenterFilePayload{
			Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(fileData)),
		}, nil
	}

	privateTrustService, err := r.PrivateTrustService(ctx, input.TrustCenterFileID.TenantID())
	if err != nil {
		return nil, fmt.Errorf("cannot export trust center file: %w", err)
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		ndaExists := true
		hasAcceptedNDA := false

		trustCenter, _, err := privateTrustService.TrustCenters.Get(ctx, tokenData.TrustCenterID)
		if err != nil {
			panic(fmt.Errorf("cannot get trust center: %w", err))
		}
		if trustCenter.NonDisclosureAgreementFileID == nil {
			ndaExists = false
		}

		if ndaExists {
			hasAcceptedNDA, err = privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, tokenData.TrustCenterID, tokenData.GetEmail())
			if err != nil {
				panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
			}
		}

		fileAccess, err := privateTrustService.TrustCenterAccesses.LoadTrustCenterFileAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), input.TrustCenterFileID)
		if err != nil {
			panic(fmt.Errorf("cannot check trust center file access: %w", err))
		}

		if !fileAccess.Active {
			return nil, fmt.Errorf("access denied: no permission to access this file")
		}

		if ndaExists && !hasAcceptedNDA {
			return nil, fmt.Errorf("user has not accepted NDA")
		}
	}

	userData := UserFromContext(ctx)
	userEmail := ""
	if userData != nil {
		userEmail = userData.EmailAddress
	}
	if tokenData != nil {
		userEmail = tokenData.GetEmail()
	}

	fileData, err := privateTrustService.TrustCenterFiles.ExportFile(ctx, input.TrustCenterFileID, userEmail)
	if err != nil {
		panic(fmt.Errorf("cannot export trust center file: %w", err))
	}

	return &types.ExportTrustCenterFilePayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(fileData)),
	}, nil
}

// LogoURL is the resolver for the logoUrl field.
func (r *organizationResolver) LogoURL(ctx context.Context, obj *types.Organization) (*string, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	return publicTrustService.Organizations.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id gid.GID) (types.Node, error) {
	publicTrustService := r.PublicTrustService(ctx, id.TenantID())

	switch id.EntityType() {
	case coredata.OrganizationEntityType:
		organization, err := publicTrustService.Organizations.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get organization: %w", err))
		}
		return types.NewOrganization(organization), nil

	case coredata.DocumentEntityType:
		document, err := publicTrustService.Documents.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get document: %w", err))
		}
		return types.NewDocument(document), nil

	case coredata.FrameworkEntityType:
		framework, err := publicTrustService.Frameworks.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get framework: %w", err))
		}
		return types.NewFramework(framework), nil

	case coredata.ReportEntityType:
		report, err := publicTrustService.Reports.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get report: %w", err))
		}
		return types.NewReport(report), nil

	case coredata.AuditEntityType:
		audit, err := publicTrustService.Audits.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get audit: %w", err))
		}
		return types.NewAudit(audit), nil

	case coredata.VendorEntityType:
		vendor, err := publicTrustService.Vendors.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get vendor: %w", err))
		}
		return types.NewVendor(vendor), nil

	case coredata.TrustCenterEntityType:
		trustCenter, file, err := publicTrustService.TrustCenters.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get trust center: %w", err))
		}
		return types.NewTrustCenter(trustCenter, file), nil

	case coredata.TrustCenterReferenceEntityType:
		reference, err := publicTrustService.TrustCenterReferences.Get(ctx, id)
		if err != nil {
			panic(fmt.Errorf("failed to get trust center reference: %w", err))
		}
		return types.NewTrustCenterReference(reference), nil

	default:
		return nil, gqlerror.Errorf("node %q not found", id)
	}
}

// TrustCenterBySlug is the resolver for the trustCenterBySlug field.
func (r *queryResolver) TrustCenterBySlug(ctx context.Context, slug string) (*types.TrustCenter, error) {
	rootTrustService := r.RootTrustService(ctx)

	trustCenter, err := rootTrustService.TrustCenters.GetBySlug(ctx, slug)
	if err != nil {
		return nil, nil
	}

	if !trustCenter.Active {
		return nil, nil
	}

	publicTrustService := r.PublicTrustService(ctx, trustCenter.TenantID)
	trustCenter, file, err := publicTrustService.TrustCenters.Get(ctx, trustCenter.ID)
	if err != nil {
		panic(fmt.Errorf("cannot get trust center: %w", err))
	}

	org, err := publicTrustService.Organizations.Get(ctx, trustCenter.OrganizationID)
	if err != nil {
		panic(fmt.Errorf("cannot get organization: %w", err))
	}
	response := types.NewTrustCenter(trustCenter, file)
	response.Organization = types.NewOrganization(org)

	return response, nil
}

// CurrentTrustCenter is the resolver for the currentTrustCenter field.
func (r *queryResolver) CurrentTrustCenter(ctx context.Context) (*types.TrustCenter, error) {
	// Get organization and tenant from custom domain context
	organizationID, ok := GetCustomDomainOrganizationID(ctx)
	if !ok {
		return nil, fmt.Errorf("organization not found for custom domain")
	}

	tenantID, ok := GetCustomDomainTenantID(ctx)
	if !ok {
		return nil, fmt.Errorf("tenant not found for custom domain")
	}

	publicTrustService := r.PublicTrustService(ctx, tenantID)

	trustCenter, err := publicTrustService.TrustCenters.GetByOrganizationID(ctx, organizationID)
	if err != nil {
		return nil, fmt.Errorf("cannot load trust center: %w", err)
	}

	if !trustCenter.Active {
		return nil, nil
	}

	trustCenter, file, err := publicTrustService.TrustCenters.Get(ctx, trustCenter.ID)
	if err != nil {
		panic(fmt.Errorf("cannot get trust center: %w", err))
	}

	org, err := publicTrustService.Organizations.Get(ctx, organizationID)
	if err != nil {
		panic(fmt.Errorf("cannot get organization: %w", err))
	}
	response := types.NewTrustCenter(trustCenter, file)
	response.Organization = types.NewOrganization(org)

	return response, nil
}

// IsUserAuthorized is the resolver for the isUserAuthorized field.
func (r *reportResolver) IsUserAuthorized(ctx context.Context, obj *types.Report) (bool, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	audit, err := publicTrustService.Audits.GetByReportID(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load document: %w", err))
	}

	if audit.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return true, nil
	}

	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return true, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		reportAccess, err := privateTrustService.TrustCenterAccesses.LoadReportAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), obj.ID)
		if err != nil {
			return false, nil
		}

		return reportAccess.Active, nil
	}

	panic(fmt.Errorf("no user or token data found"))
}

// HasUserRequestedAccess is the resolver for the hasUserRequestedAccess field.
func (r *reportResolver) HasUserRequestedAccess(ctx context.Context, obj *types.Report) (bool, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return false, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		_, err := privateTrustService.TrustCenterAccesses.LoadReportAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), obj.ID)
		if err != nil {
			return false, nil
		}
		return true, nil
	}

	return false, nil
}

// NdaFileURL is the resolver for the ndaFileUrl field.
func (r *trustCenterResolver) NdaFileURL(ctx context.Context, obj *types.TrustCenter) (*string, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return nil, nil
	}

	fileURL, err := privateTrustService.TrustCenters.GenerateNDAFileURL(ctx, obj.ID, 15*time.Minute)
	if err != nil {
		return nil, nil
	}

	return &fileURL, nil
}

// Organization is the resolver for the organization field.
func (r *trustCenterResolver) Organization(ctx context.Context, obj *types.TrustCenter) (*types.Organization, error) {
	return obj.Organization, nil
}

// IsUserAuthenticated is the resolver for the isUserAuthenticated field.
func (r *trustCenterResolver) IsUserAuthenticated(ctx context.Context, obj *types.TrustCenter) (bool, error) {
	_, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	return true, nil
}

// HasAcceptedNonDisclosureAgreement is the resolver for the hasAcceptedNonDisclosureAgreement field.
func (r *trustCenterResolver) HasAcceptedNonDisclosureAgreement(ctx context.Context, obj *types.TrustCenter) (bool, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := UserFromContext(ctx)
	if userData != nil {
		return true, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		hasAcceptedNDA, err := privateTrustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, obj.ID, tokenData.GetEmail())
		if err != nil {
			panic(fmt.Errorf("cannot check if user has accepted NDA: %w", err))
		}
		return hasAcceptedNDA, nil
	}

	panic(fmt.Errorf("no user or token data found"))
}

// Documents is the resolver for the documents field.
func (r *trustCenterResolver) Documents(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.DocumentConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.DocumentOrderField]{
		Field:     coredata.DocumentOrderFieldTitle,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	documentPage, err := publicTrustService.Documents.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public documents: %w", err))
	}

	return types.NewDocumentConnection(documentPage), nil
}

// Audits is the resolver for the audits field.
func (r *trustCenterResolver) Audits(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.AuditConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.AuditOrderField]{
		Field:     coredata.AuditOrderFieldValidFrom,
		Direction: page.OrderDirectionDesc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	auditPage, err := publicTrustService.Audits.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public audits: %w", err))
	}

	return types.NewAuditConnection(auditPage), nil
}

// Vendors is the resolver for the vendors field.
func (r *trustCenterResolver) Vendors(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.VendorConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.VendorOrderField]{
		Field:     coredata.VendorOrderFieldName,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	vendorPage, err := publicTrustService.Vendors.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public vendors: %w", err))
	}

	return types.NewVendorConnection(vendorPage), nil
}

// References is the resolver for the references field.
func (r *trustCenterResolver) References(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.TrustCenterReferenceConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.TrustCenterReferenceOrderField]{
		Field:     coredata.TrustCenterReferenceOrderFieldRank,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	referencePage, err := publicTrustService.TrustCenterReferences.ListForTrustCenterID(ctx, obj.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public trust center references: %w", err))
	}

	return types.NewTrustCenterReferenceConnection(referencePage), nil
}

// TrustCenterFiles is the resolver for the trustCenterFiles field.
func (r *trustCenterResolver) TrustCenterFiles(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.TrustCenterFileConnection, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.TrustCenterFileOrderField]{
		Field:     coredata.TrustCenterFileOrderFieldName,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	trustCenterFilePage, err := publicTrustService.TrustCenterFiles.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		panic(fmt.Errorf("cannot list public trust center files: %w", err))
	}

	return types.NewTrustCenterFileConnection(trustCenterFilePage), nil
}

// IsUserAuthorized is the resolver for the isUserAuthorized field.
func (r *trustCenterFileResolver) IsUserAuthorized(ctx context.Context, obj *types.TrustCenterFile) (bool, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	trustCenterFile, err := publicTrustService.TrustCenterFiles.Get(ctx, obj.ID)
	if err != nil {
		panic(fmt.Errorf("cannot load trust center file: %w", err))
	}

	if trustCenterFile.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return true, nil
	}

	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return true, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		fileAccess, err := privateTrustService.TrustCenterAccesses.LoadTrustCenterFileAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), obj.ID)
		if err != nil {
			return false, nil
		}

		return fileAccess.Active, nil
	}

	panic(fmt.Errorf("no user or token data found"))
}

// HasUserRequestedAccess is the resolver for the hasUserRequestedAccess field.
func (r *trustCenterFileResolver) HasUserRequestedAccess(ctx context.Context, obj *types.TrustCenterFile) (bool, error) {
	privateTrustService, err := r.PrivateTrustService(ctx, obj.ID.TenantID())
	if err != nil {
		return false, nil
	}

	userData := r.UserFromContext(ctx)
	if userData != nil {
		return false, nil
	}

	tokenData := TokenAccessFromContext(ctx)
	if tokenData != nil {
		_, err := privateTrustService.TrustCenterAccesses.LoadTrustCenterFileAccess(ctx, tokenData.TrustCenterID, tokenData.GetEmail(), obj.ID)
		if err != nil {
			return false, nil
		}
		return true, nil
	}

	return false, nil
}

// LogoURL is the resolver for the logoUrl field.
func (r *trustCenterReferenceResolver) LogoURL(ctx context.Context, obj *types.TrustCenterReference) (string, error) {
	publicTrustService := r.PublicTrustService(ctx, obj.ID.TenantID())

	logoURL, err := publicTrustService.TrustCenterReferences.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
	if err != nil {
		panic(fmt.Errorf("cannot generate logo URL: %w", err))
	}

	return logoURL, nil
}

// Audit returns schema.AuditResolver implementation.
func (r *Resolver) Audit() schema.AuditResolver { return &auditResolver{r} }

// Document returns schema.DocumentResolver implementation.
func (r *Resolver) Document() schema.DocumentResolver { return &documentResolver{r} }

// Mutation returns schema.MutationResolver implementation.
func (r *Resolver) Mutation() schema.MutationResolver { return &mutationResolver{r} }

// Organization returns schema.OrganizationResolver implementation.
func (r *Resolver) Organization() schema.OrganizationResolver { return &organizationResolver{r} }

// Query returns schema.QueryResolver implementation.
func (r *Resolver) Query() schema.QueryResolver { return &queryResolver{r} }

// Report returns schema.ReportResolver implementation.
func (r *Resolver) Report() schema.ReportResolver { return &reportResolver{r} }

// TrustCenter returns schema.TrustCenterResolver implementation.
func (r *Resolver) TrustCenter() schema.TrustCenterResolver { return &trustCenterResolver{r} }

// TrustCenterFile returns schema.TrustCenterFileResolver implementation.
func (r *Resolver) TrustCenterFile() schema.TrustCenterFileResolver {
	return &trustCenterFileResolver{r}
}

// TrustCenterReference returns schema.TrustCenterReferenceResolver implementation.
func (r *Resolver) TrustCenterReference() schema.TrustCenterReferenceResolver {
	return &trustCenterReferenceResolver{r}
}

type auditResolver struct{ *Resolver }
type documentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type organizationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reportResolver struct{ *Resolver }
type trustCenterResolver struct{ *Resolver }
type trustCenterFileResolver struct{ *Resolver }
type trustCenterReferenceResolver struct{ *Resolver }
